/*
 * \file draw_progress.c
 *
 * \brief  画系统启动进度条
 *
 */
#include <linux/init.h>
#include <linux/workqueue.h>
#include <linux/fb.h>
#include <linux/slab.h>
#include <asm/io.h>
#include <linux/delay.h>
#include <asm/cacheflush.h>
#include <linux/time.h>

#define CONFIG_PROCESS_DURATION 10

#define RGB(red, green, blue)  ((red << 16) | (green << 8) | (blue))
#define PROGRESS_FILL_COLOR        RGB(123, 123, 123) //填充为灰色
#define PROGRESS_BACKGROUND_COLOR  RGB(40, 40, 40) //进度条背景颜色
#define PROGRESS_BAR_TEST_COLOR  RGB(255, 0, 0) //进度条TEST颜色
#define LCD_WIDTH    480  //LCD宽度
#define LCD_HEIGHT   272  //LCD长度

#define PROGRESS_WIDTH          (LCD_WIDTH*3/4) //进度条长度为屏宽的3/4
#define PROGRESS_HEIGTH         (4)             //进度条的高度为4像素点
#define PROGRESS_BLOCK_LEN      (1)             //每次绘制进度条的长度
#define PROGRESS_UBOOT_DRAW_LEN (0)            //进度条在uboot中已经绘制的长度 20

//绘制进度条的起始位置，原点在左上角(x,y)坐标点
#define PROGRESS_START_X      ((LCD_WIDTH-PROGRESS_WIDTH)/2)
#define PROGRESS_START_Y      (216)
#define PROGRESS_START_POS    (PROGRESS_START_Y * LCD_WIDTH + PROGRESS_START_X)


//映射为linux地址 //0x6400000+0xC0000000   framebuffer+0x0c000000
// #define RIGOL_LCD_FB_ADDR   0xC7000000//0xC7000000// default 0xC6400000
#define RIGOL_LCD_FB_ADDR       0xC6400000
#define CONFIG_SYS_SDRAM_BASE   0xC0000000
static struct delayed_work boot_process_work;
static struct workqueue_struct *mywork;
static struct class *boot_process_class;
static int boot_process_stop_flag;
static void boot_process_exit(void);

char alpha[432][2] = {
	
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xC0,0x30,0x60,
	0x00,0x60,0x1F,0xE0,0x30,0x60,0x30,0xE0,0x1F,0x60,0x00,0x00,0x00,0x00,0x00,0x00,/*"a",0*/

	0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00,0x30,0x00,0x30,0x00,0x37,0x80,0x38,0xC0,
	0x30,0x60,0x30,0x60,0x30,0x60,0x38,0xC0,0x37,0x80,0x00,0x00,0x00,0x00,0x00,0x00,/*"b",1*/

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xC0,0x30,0x60,
	0x60,0x00,0x60,0x00,0x60,0x00,0x20,0x60,0x1F,0x80,0x00,0x00,0x00,0x00,0x00,0x00,/*"c",2*/

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0xC0,0x00,0xC0,0x1E,0xC0,0x31,0xC0,
	0x60,0xC0,0x60,0xC0,0x60,0xC0,0x31,0xC0,0x1E,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,/*"d",3*/

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x80,0x30,0xC0,
	0x60,0x60,0x7F,0xE0,0x60,0x00,0x30,0x60,0x1F,0x80,0x00,0x00,0x00,0x00,0x00,0x00,/*"e",4*/

	0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xE0,0x06,0x00,0x06,0x00,0x3F,0xC0,0x06,0x00,
	0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*"f",5*/

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1E,0xC0,0x31,0xC0,
	0x60,0xC0,0x60,0xC0,0x60,0xC0,0x31,0xC0,0x1E,0xC0,0x00,0xC0,0x61,0x80,0x3F,0x00,/*"g",6*/

	0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00,0x30,0x00,0x30,0x00,0x37,0x80,0x38,0xC0,
	0x30,0xC0,0x30,0xC0,0x30,0xC0,0x30,0xC0,0x30,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,/*"h",7*/

	0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x1F,0x00,0x03,0x00,
	0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*"i",8*/

	0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x1F,0x00,0x03,0x00,
	0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x3E,0x00,/*"j",9*/

	0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00,0x30,0x00,0x30,0x00,0x30,0xC0,0x33,0x80,
	0x36,0x00,0x3E,0x00,0x3B,0x00,0x31,0x80,0x30,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,/*"k",10*/

	0x00,0x00,0x00,0x00,0x00,0x00,0x3E,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,
	0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*"l",11*/

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x6E,0xC0,0x77,0x60,
	0x66,0x60,0x66,0x60,0x66,0x60,0x66,0x60,0x66,0x60,0x00,0x00,0x00,0x00,0x00,0x00,/*"m",12*/

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x37,0x80,0x38,0xC0,
	0x30,0xC0,0x30,0xC0,0x30,0xC0,0x30,0xC0,0x30,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,/*"n",13*/

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x80,0x30,0xC0,
	0x60,0x60,0x60,0x60,0x60,0x60,0x30,0xC0,0x1F,0x80,0x00,0x00,0x00,0x00,0x00,0x00,/*"o",14*/

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x37,0x80,0x38,0xC0,
	0x30,0x60,0x30,0x60,0x30,0x60,0x38,0xC0,0x37,0x80,0x30,0x00,0x30,0x00,0x30,0x00,/*"p",15*/

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1E,0xC0,0x31,0xC0,
	0x60,0xC0,0x60,0xC0,0x60,0xC0,0x31,0xC0,0x1E,0xC0,0x00,0xC0,0x00,0xC0,0x00,0xC0,/*"q",16*/

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0xC0,0x1C,0x40,
	0x18,0x00,0x18,0x00,0x18,0x00,0x18,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*"r",17*/

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x80,0x30,0xC0,
	0x33,0x80,0x3F,0xC0,0x00,0xC0,0x30,0xC0,0x1F,0x80,0x00,0x00,0x00,0x00,0x00,0x00,/*"s",18*/

	0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x0C,0x00,0x0C,0x00,0x7F,0xC0,0x0C,0x00,
	0x0C,0x00,0x0C,0x00,0x0C,0x00,0x0C,0x00,0x07,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,/*"t",19*/

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0xC0,0x30,0xC0,
	0x30,0xC0,0x30,0xC0,0x30,0xC0,0x31,0xC0,0x1E,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,/*"u",20*/

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0xC0,0x31,0x80,
	0x31,0x80,0x1B,0x00,0x1B,0x00,0x0E,0x00,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*"v",21*/

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC4,0x60,0xCE,0x60,
	0x6A,0xC0,0x6A,0xC0,0x2A,0x80,0x32,0x80,0x11,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*"w",22*/

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0xE0,0x19,0x80,
	0x0F,0x00,0x06,0x00,0x0F,0x00,0x19,0x80,0x70,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,/*"x",23*/

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0xC0,0x31,0x80,
	0x31,0x80,0x1B,0x00,0x1B,0x00,0x0E,0x00,0x0E,0x00,0x0C,0x00,0x0C,0x00,0x38,0x00,/*"y",24*/

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xE0,0x01,0xC0,
	0x03,0x80,0x07,0x00,0x1C,0x00,0x38,0x00,0x7F,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,/*"z",25*/


	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*".",0*/
                                                                   
};


//char
static int draw_char(unsigned int *framebuffer, int pos)
{
    int i, j, k;
    int mask = 0x80;
    unsigned int *buf = framebuffer - LCD_WIDTH * 17;
    for(i = pos; i < pos + 16; i++)
    {
		for(j = 0; j < 2; j++)
		{
			for(k = 0; k < 8; k++)
			{
				if(alpha[i][j] & (mask >> k))
				{
					memset(&buf[(i - pos) * 480 + j * 8 + k], PROGRESS_FILL_COLOR, 4);
				}
			}
		}
	}
	 
	return 0;     
}

//string
static int draw_string(unsigned int *framebuffer, char *string)
{
	int i;
	int u32CharPos;
	unsigned int *pTempBuf = framebuffer;
	for(i = 0; i < strlen(string); i++)
	{
		if('.' == string[i])
		{
			u32CharPos = 26 * 16;
			draw_char(pTempBuf, u32CharPos);
		}
		else if(' ' == string[i])
		{
		}
		else 
		{
			u32CharPos = (string[i] - 'a') * 16;
			draw_char(pTempBuf, u32CharPos);
		}
		pTempBuf += 10;
	}
	
	return 0;
}

	
static void process_worker(struct work_struct *work)  //定时画进度条
{
    /* 静态变量 */
    static unsigned long u64Timestamp = 0;
    static unsigned int *pu32FbBase;
    static unsigned int  u32ProgressAlreadyLen;
    static unsigned int  u32BlocklenAjust;
    static unsigned long delay;
    /* 临时变量 */
    int i, j;
    unsigned int u32ProgressCurrentPos, u32ProgressStartPos;
	struct timeval startime, endtime;
	long costime = 0;
	long sec = 0;
	static long long sumtime = 0;
	
	do_gettimeofday(&startime);
    if (boot_process_stop_flag != 0) {
        printk("Stop boot process successfully!\n");
        return;
    }

    /* fisrt call process_worker, set timestamp as jiffies */
    if (u64Timestamp == 0) 
    {
        pu32FbBase = (u32 *)((unsigned int)RIGOL_LCD_FB_ADDR);//+ 0x01000000
        u64Timestamp = jiffies;//时间戳
        u32ProgressAlreadyLen = PROGRESS_UBOOT_DRAW_LEN;//uboot中已画长度
        u32BlocklenAjust = (PROGRESS_WIDTH - PROGRESS_UBOOT_DRAW_LEN) / PROGRESS_BLOCK_LEN;//（进度条长度-uboot画的长度）/每次画的长度
        delay = CONFIG_PROCESS_DURATION * HZ / (u32BlocklenAjust); // 延迟时间 HZ 原值为100
        //draw_char(pu32FbBase + PROGRESS_START_POS, 'c' - 'a');
        //draw_chinese(pu32FbBase + PROGRESS_START_POS);
		draw_string(pu32FbBase + PROGRESS_START_POS, "upgrade the system...");
        //防止uboot阶段没有绘制进度条. 会导致颜色不一样 故取消。
        for (i = 0; i < PROGRESS_WIDTH; i++) 
        {
            u32ProgressCurrentPos = PROGRESS_START_POS - LCD_WIDTH + i;
            pu32FbBase[u32ProgressCurrentPos] = PROGRESS_BAR_TEST_COLOR;
        }

        printk("progress delay = %lu, HZ = %d.\n", delay, HZ);
    }

    //计算起始点位置
    u32ProgressStartPos = PROGRESS_START_POS + u32ProgressAlreadyLen;

    for (i = 0; i < PROGRESS_BLOCK_LEN; i++) {
        //计算当前绘制列的起始位置
        u32ProgressCurrentPos = u32ProgressStartPos + i;

        for (j = 0; j < PROGRESS_HEIGTH; j++) {

            //pu32FbBase[u32ProgressCurrentPos] = PROGRESS_FILL_COLOR;
            memset(&pu32FbBase[u32ProgressCurrentPos], PROGRESS_FILL_COLOR, 4);
            u32ProgressCurrentPos += LCD_WIDTH;
        }
    }
	flush_cache_all();
	do_gettimeofday(&endtime);
	sec = endtime.tv_sec - startime.tv_sec;
	costime = sec * 1000000 + (endtime.tv_usec - startime.tv_usec);
	sumtime += costime;
	//printk("%s Cost time :%ld us\n", __FUNCTION__, costime);
    u32ProgressAlreadyLen += PROGRESS_BLOCK_LEN;
    if (u32ProgressAlreadyLen > PROGRESS_WIDTH) {
        printk("Boot process: boot process end!\n");
        printk("%s cost sum time: %lld us\n", __FUNCTION__, sumtime);
        boot_process_exit();
        return;
    }
	queue_delayed_work(mywork, &boot_process_work, delay);
    //schedule_delayed_work(&boot_process_work, delay);//延时工作队列
}


static ssize_t boot_process_stop(struct class *cls, struct class_attribute *attr, const  char *_buf, size_t _count)
{
    int stop = 0;

    sscanf(_buf, "%d", &stop);
    boot_process_stop_flag = stop;
    printk("%s: boot process stop = %d \n", __FUNCTION__, stop);

    return _count;
}

static struct class_attribute boot_process_class_attrs[] = {
    __ATTR(stop, 0666, NULL, boot_process_stop),
    __ATTR_NULL,
};

//用class_create在sys/class/下面生成sys文件系统
static int boot_process_class_init(void)
{
    int ret;
    int i = 0;
    boot_process_class = class_create(THIS_MODULE, "boot_process");

    if (IS_ERR(boot_process_class)) {
        printk("create boot_process_class fail!\n");
        return PTR_ERR(boot_process_class);
    }

    for (i = 0; NULL != boot_process_class_attrs[i].attr.name; i++) {
        ret = class_create_file(boot_process_class, &boot_process_class_attrs[i]);

        if (0 != ret) {
            printk("Create %s class file fail!\n", boot_process_class_attrs[i].attr.name);
            break;
        }
    }

    return 0;
}

int boot_process_init(void)
{
    boot_process_stop_flag = 0;
    boot_process_class_init();
    printk("******* Boot process: init(%d) *******\n", HZ);
    
    mywork = create_singlethread_workqueue("my work");
    INIT_DELAYED_WORK(&boot_process_work, process_worker);
    queue_delayed_work(mywork, &boot_process_work, 0);
    //schedule_delayed_work(&boot_process_work, 0);/*HZ/5*/
    return 0;
}

static void boot_process_exit(void)
{
	destroy_workqueue(mywork);
}

early_initcall(boot_process_init); //Setting up static identity map for 0x805c0a60 - 0x805c0ab8后
